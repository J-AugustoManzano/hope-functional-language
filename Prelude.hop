! ---------------------------------------------------------------------------- !
!                                                                              !
! Módulo Hope .........: Prelude.hop                                           !
!                                                                              !
! Simulação Haskell ...: Prelude/List                                          !
! Versão ..............: 1.0.1                                                 !
! Objetivo ............: Simulação base Haskell em Hope                        !
! Copyright ...........: (c) Augusto Manzano, 2022                             !
! Licença .............: Creative Commons CC CC BY-NC-SA 4.0 (https://creative !
!                        commons.org/licenses/by-nc-sa/4.0/legalcode.pt)       !
!                                                                              !
!                        Implementação em Hope das principais funcionalidades  !
!                        encontradas na linguagem Haskell. Apoio operacional a !
!                        partir de algumas operações existentes nos módulos    !
!                        padrão "Prelude" e "List".                            !
!                        Algumas funções do Prelude/List não estão incluídas   !
!                        neste arquivo. Há funções exstentes neste arquivo que !
!                        não são partes do pacote "Prelude" e "List".          !
!                                                                              !
! Estabilidade ........: Experimental (em desenvolvimento)                     !
! Dependência .........: Standard.hop (modificada para suporte)                !
!                        Incluído neste pacote.                                !
!                                                                              !
! ---------------------------------------------------------------------------- !     

! !!! -------------------------------------------------------------------- !!! !
! !!! SIMULAÇÃO MÓDULO "PRELUDE"                                           !!! !
! !!! -------------------------------------------------------------------- !!! !

all : (alpha -> truval) # list alpha -> truval;
all (_, [])      <= true;
all (p, x :: xs) <= p x and all (p, xs);

any : (alpha -> truval) # list alpha -> truval;
any (_, [])      <= false;
any (p, x :: xs) <= p x or any (p, xs); 

!!!!! break

!!!!! compare

concat : list (list alpha) -> list alpha;
concat []        <= [];
concat (x :: xs) <= x <> concat xs;

concatMap : (alpha -> list beta) # list alpha -> list beta;
concatMap (f, []) <= [];
concatMap (f, x :: xs) <= f x <> concatMap (f, xs);
!! >: concatMap(\x => [x+2], [1,3,5]);
!! >> [3, 5, 7] : list num

curry : (alpha # beta -> gamma) -> alpha -> beta -> gamma;
curry f <= lambda x => lambda y => f(x, y);
!! >: curry fst 2 3;
!! >> 2 : num

cycle : list num -> list num;
cycle [] <= error ("Lista vazia!");
cycle (x :: xs) <= x :: cycle (xs <> [x]);

drop : num # list alpha -> list alpha;
drop (0, xs)      <= xs;
drop (n, [])      <= [];
drop (n, x :: xs) <= drop (n - 1, xs);

dropWhile : (alpha -> truval) # list alpha -> list alpha;
dropWhile (_, [])      <= [];
dropWhile (p, x :: xs) <= if p x 
                          then dropWhile (p, xs) 
                          else x :: xs;

elem : alpha # list alpha -> truval;
elem (x, [])      <= false;
elem (x, y :: ys) <= x = y or elem (x, ys);

member : alpha # list alpha -> truval;
member <= elem;    

unique : list alpha -> list alpha;
unique []        <= [];
unique (x :: xs) <= if member (x, xs) 
                    then unique xs 
                    else x :: unique xs;     

filter : (alpha -> truval) # list alpha -> list alpha;
filter (_, [])      <= [];
filter (p, x :: xs) <= if p x 
                       then x :: filter (p, xs) 
                       else filter (p, xs);

foldl : (alpha # beta -> alpha) # alpha # list beta -> alpha;
foldl (f, n, [])      <= n;
foldl (f, n, x :: xs) <= foldl (f, f (n, x), xs);

foldr : (alpha # beta -> beta) # beta # list alpha -> beta;
foldr (f, n, [])      <= n;
foldr (f, n, x :: xs) <= f (x, foldr (f, n, xs));

concat2lst : list alpha # list alpha -> list alpha;
concat2lst (xs, ys) <= foldr ((::), ys, xs);

foldl1 : (alpha # alpha -> alpha) # list alpha -> alpha;
foldl1 (f, x :: xs) <= foldl (f, x, xs);

foldr1 : (alpha # alpha -> alpha) # list alpha -> alpha;
foldr1 (f, [x]) <= x;
foldr1 (f, x :: xs) <= f (x, foldr1 (f, xs));

head : list alpha -> alpha;
head []       <= error ("Empty list!");
head (x :: _) <= x;

init : list alpha -> list alpha;
init ([x])     <= [];
init (x :: xs) <= x :: init xs;

insert : alpha # list alpha -> list alpha;
insert (n, [])      <= [n];
insert (n, x :: xs) <= if n =< x 
                       then n :: x :: xs 
                       else x :: insert (n, xs);

intersperse : alpha # list alpha -> list alpha;
intersperse  (_, []) <= [];
intersperse  (_, [x]) <= [x];
intersperse (n, x :: xs) <= x :: n :: intersperse (n, xs);
!! >: intersperse (0, [1, 2, 3, 4, 5]);
!! >> [1, 0, 2, 0, 3, 0, 4, 0, 5] : list num

sort : list alpha -> list alpha;
sort []        <= [];
sort (x :: xs) <= insert (x, sort xs);

last : list alpha -> alpha;
last ([x])     <= x;
last (x :: xs) <= last xs;

length : list alpha -> num;
length []        <= 0;
length (x :: xs) <= 1 + length xs;

listPow : num # list num -> list num;
listPow (_, [])      <= [];
listPow (n, x :: xs) <= pow (x, n) :: listPow (n, xs);

getPos : alpha # list alpha -> num;
getPos (_, [])      <= error ("Element does not exist in the list!");
getPos (n, x :: xs) <= if n = x 
                       then length xs 
                       else getPos (n, xs);

lookup : alpha # list (alpha # beta) -> beta;
lookup (_, []) <= error "Data not found!";
lookup (k, ((x, y) :: xyz)) <= if k = x
                               then y
                               else lookup (k, xyz);
!! >: lookup ('c', [('a', 0), ('b', 1), ('c', 2)]);
!! >> 2 : num                               

map : (alpha -> beta) # list alpha -> list beta;
map (_, [])      <= [];
map (f, x :: xs) <= f x :: map (f, xs);

maximum : list alpha -> alpha;
maximum []             <= error ("Empty list!");
maximum ([x])          <= x;
maximum (x :: y :: xs) <= if x > y 
                          then maximum (x :: xs) 
                          else maximum (y :: xs);

minimum : list alpha -> alpha;
minimum []             <= error ("Empty list!");
minimum ([x])          <= x;
minimum (x :: y :: xs) <= if x < y 
                          then minimum (x :: xs) 
                          else minimum (y :: xs);

null : list alpha -> truval;
null []       <= true;
null (_ :: _) <= false;

print : alpha -> alpha;
print n <= n;
!! >: print "alo";
!! >> "alo" : list char
!! >: print [1,2,3]<>[4,5];
!! >> [1, 2, 3, 4, 5] : list num

product : list num -> num;
product xs <= foldl ((*), 1, xs);

quotRem : num # num -> (num # num);
quotRem (a, b) <= (a div b, a mod b);

range : num # num # num -> list num;
range (i, f, p) <= if i > f 
                   then [] 
                   else i :: range (i + p, f, p);

reduce : list alpha # (alpha # alpha -> alpha) # alpha -> alpha;
reduce ([], f, n)      <= n;
reduce (x :: xs, f, n) <= f (x, reduce (xs, f, n));

reverseAux : list alpha # list alpha -> list alpha;
reverseAux([], ys)    <= ys;
reverseAux(x::xs, ys) <= reverseAux(xs, x::ys);

reverse : list alpha -> list alpha;
reverse xs <= reverseAux(xs, []);

find : alpha # list alpha -> num;
find (_, [])      <= error ("Empty list!");
find (n, x :: xs) <= getPos (n, reverse (x :: xs));

scanl : (beta # alpha -> beta) # beta # list alpha -> list beta;
scanl (_, n, []) <= [n];
scanl (f, n, x :: xs) <= n :: scanl (f, f (n, x), xs);

scanl1 : (alpha #alpha -> alpha) # list alpha -> list alpha;
scanl1 (_, []) <= [];
scanl1 (f, x :: xs) <= scanl (f, x, xs);

!!!!! scanr

!!!!! scanr1

take : num # list alpha -> list alpha;
take (n, [])      <= [];
take (0, xs)      <= [];
take (n, x :: xs) <= x :: take (n - 1, xs);

iterate : (alpha -> alpha) # alpha -> list alpha;
iterate (f, x) <= x :: iterate (f, f x);
!! >: take (10, (iterate (\x => x * 2, 1)));
!! >> [1, 2, 4, 8, 16, 32, 64, 128, 256, 512] : list num

repeat : alpha -> list alpha;
repeat x <= x :: repeat x;

replicate : num # alpha -> list alpha;
replicate (n, x) <= take (n, repeat x);

splitAt : num # list alpha -> list alpha # list alpha;
splitAt (n, xs) <= (take (n, xs), drop (n, xs));

splitAt' : num # list alpha -> list alpha # list alpha;
splitAt' (0, ys)      <= ([], ys);
splitAt' (_, [])      <= ([], []);
splitAt' (n, y :: ys) <= if n < 0 
                         then ([], y :: ys) 
                         else (y :: a, b) 
                         where (a, b) == splitAt' (n - 1, ys);  

subtract : num # num -> num;
subtract (x, y) <= y - x;

sum : list num -> num;
sum []        <= 0;
sum (x :: xs) <= x + sum xs;  

tail : list alpha -> list alpha;
tail []        <= error ("Empty list!");
tail (_ :: xs) <= xs;

takeWhile : (alpha -> truval) # list alpha -> list alpha;
takeWhile (_, [])      <= [];
takeWhile (p, x :: xs) <= if p x 
                          then x :: takeWhile (p, xs) 
                          else [];

uncurry : (alpha -> beta -> gamma) -> alpha # beta -> gamma;
uncurry f (x, y) <= f x y;

until : (alpha -> truval) # (alpha -> alpha) # alpha -> alpha;
until (p, f, x) <= if p x 
                   then x 
                   else until (p, f, f x);

unwordsAux : list (list char) -> list char;
unwordsAux [] <= [];
unwordsAux (x :: xs) <= x <> " " <> unwordsAux xs;

unwords : list (list char) -> list char;
unwords lst <= init (unwordsAux lst);

unzipAux : list alpha # list alpha # list (alpha # alpha) -> list alpha # list alpha;
unzipAux (xs, ys, []) <= (reverse xs, reverse ys);
unzipAux (xs, ys, (x, y) :: zs) <= unzipAux (x :: xs, y :: ys, zs);

unzip : list (alpha # alpha) -> list alpha # list alpha;
unzip [] <= ([], []);
unzip xs <= unzipAux ([], [], xs);

unzipAux3 : list alpha # list alpha # list alpha # list (alpha # alpha # alpha) -> list alpha # list alpha # list alpha;
unzipAux3 (xs, ys, zs, []) <= (reverse xs, reverse ys, reverse zs);
unzipAux3 (xs, ys, zs, (x, y, z) :: as) <= unzipAux3 (x :: xs, y :: ys, z :: zs, as);

unzip3 : list (alpha # alpha # alpha) -> list alpha # list alpha # list alpha;
unzip3 [] <= ([], [], []);
unzip3 xs <= unzipAux3 ([], [], [], xs);

!!!!! unzip4

!!!!! unzip5

!!!!! unzip6

!!!!! unzip7

words : list char -> list (list char);
  wordsAux : list char -> list(list char);
  wordsAux "" <= [];
  wordsAux cs <= w :: words rest where (w, rest) == span (not o isSpace) cs;
words cs <= wordsAux (afterWith isSpace cs);

zip : list alpha # list beta -> list (alpha # beta);
zip ([], _)            <= [];
zip (_, [])            <= [];
zip (x :: xs, y :: ys) <= (x, y) :: zip (xs, ys);

zip3 : (list alpha # list beta # list gamma) -> list (alpha # beta # gamma);
zip3 (_, _, _) <= [];
zip3 (a :: as, b :: bs, c :: cs) <= (a, b, c) :: zip3 (as, bs, cs);

zip4 : list alpha # list beta # list gamma # list delta -> list (alpha # beta # gamma # delta);
zip4 (_, _, _, _) <= [];
zip4 (a :: as, b :: bs, c :: cs, d :: ds) <= (a, b, c, d) :: zip4 (as, bs, cs, ds);

!!!!! zip5

!!!!! zip6

!!!!! zip7

zipWith : (alpha # beta -> gamma) # list alpha # list beta -> list gamma;
zipWith (_, _, _) <= [];
zipWith (f, x :: xs, y :: ys) <= f (x, y) :: zipWith (f, xs, ys);

zipWith3 : (alpha # beta # gamma -> delta) # list alpha # list beta # list gamma -> list delta;
zipWith3 (_, _, _) <= [];
zipWith3 (f, a :: ax, b :: bx, c :: cx) <= f (a, b, c) :: zipWith3 (f, ax, bx, cx);
!! :> zipWith3 ((\x, y, z => x+2*y+3*z), 1..5, 5..10, 10..15);
!! >> [41, 47, 53, 59, 65] : list num
